<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BENNY BOOâ€”PHYSICAL GENIUS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Caveat:wght@600&family=Cinzel:wght@600;700&family=Rajdhani:wght@400;600&family=Spectral:ital,wght@0,400;0,600;1,400&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <link rel="icon" href="favicon.ico" sizes="any" />
    <script type="importmap">
      {
        "imports": {
          "three": "./vendor/three/three.module.js",
          "three/addons/": "./vendor/three/addons/",
          "cannon-es": "./vendor/cannon-es/cannon-es.js"
        }
      }
    </script>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #02040b;
        font-family: "Spectral", serif;
      }

      #app {
        position: fixed;
        inset: 0;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: grab;
      }

      canvas.is-dragging {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module">
      import * as THREE from "three";
      import * as CANNON from "cannon-es";
      import { RoundedBoxGeometry } from "three/addons/geometries/RoundedBoxGeometry.js";

      const app = document.getElementById("app");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog("#02040b", 8, 24);

      const camera = new THREE.PerspectiveCamera(
        38,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 0, 7.2);

      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
      keyLight.position.set(2.5, 4, 6);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x88ccff, 0.4);
      fillLight.position.set(-3, -2, 5);
      scene.add(fillLight);

      const motionEnabled = !window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;

      const cardSpec = {
        name: "Benny Boo, the Physical Genius",
        attribute: "EARTH",
        typeLine: "Type: Warrior / Effect",
        level: 6,
        effectText:
          "This card gains 300 ATK for each face-up card on the field. Once per turn (Quick Effect): you can target 1 face-up card on the field; negate its effects until the end of the turn, then you can destroy it. If a card is destroyed by this effect: banish it. If this card would be destroyed, you can negate that destruction.",
        flavorText: "\"He hears it before it happens.\"",
        atk: "2300",
        def: "2000",
        backText: "call +1 (916) 799-4473 for a good time"
      };

        const loadImage = (src) =>
          new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => resolve(null);
            img.crossOrigin = "anonymous";
            img.src = src;
          });

      const drawRoundedRect = (ctx, x, y, w, h, r) => {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      };

      const createRoundedRectShape = (width, height, radius) => {
        const halfW = width / 2;
        const halfH = height / 2;
        const r = Math.min(radius, halfW, halfH);
        const shape = new THREE.Shape();
        shape.moveTo(-halfW + r, -halfH);
        shape.lineTo(halfW - r, -halfH);
        shape.quadraticCurveTo(halfW, -halfH, halfW, -halfH + r);
        shape.lineTo(halfW, halfH - r);
        shape.quadraticCurveTo(halfW, halfH, halfW - r, halfH);
        shape.lineTo(-halfW + r, halfH);
        shape.quadraticCurveTo(-halfW, halfH, -halfW, halfH - r);
        shape.lineTo(-halfW, -halfH + r);
        shape.quadraticCurveTo(-halfW, -halfH, -halfW + r, -halfH);
        return shape;
      };

      const drawStar = (ctx, cx, cy, spikes, outerRadius, innerRadius) => {
        let rot = (Math.PI / 2) * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i += 1) {
          x = cx + Math.cos(rot) * outerRadius;
          y = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(x, y);
          rot += step;

          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(x, y);
          rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
      };

      const wrapText = (ctx, text, maxWidth) => {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        words.forEach((word) => {
          const testLine = currentLine ? `${currentLine} ${word}` : word;
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        });

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      };

      const drawImageCover = (ctx, img, x, y, w, h) => {
        if (!img) {
          ctx.fillStyle = "rgba(255,255,255,0.08)";
          ctx.fillRect(x, y, w, h);
          return;
        }

        const imgRatio = img.width / img.height;
        const areaRatio = w / h;
        let sx = 0;
        let sy = 0;
        let sw = img.width;
        let sh = img.height;

        if (imgRatio > areaRatio) {
          sh = img.height;
          sw = sh * areaRatio;
          sx = (img.width - sw) / 2;
        } else {
          sw = img.width;
          sh = sw / areaRatio;
          sy = (img.height - sh) / 2;
        }

        ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
      };

      const buildFrontTexture = (image) => {
        const width = 1024;
        const height = Math.round((width * 86) / 59);
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        const scale = width / 420;

        const frameGradient = ctx.createLinearGradient(0, 0, width, height);
        frameGradient.addColorStop(0, "#e6c98b");
        frameGradient.addColorStop(0.45, "#7b5e2e");
        frameGradient.addColorStop(1, "#1e1a12");

        drawRoundedRect(ctx, 0, 0, width, height, 16 * scale);
        ctx.fillStyle = frameGradient;
        ctx.fill();

        const outerPad = 12 * scale;
        const innerX = outerPad;
        const innerY = outerPad;
        const innerW = width - outerPad * 2;
        const innerH = height - outerPad * 2;
        const innerGradient = ctx.createLinearGradient(
          innerX,
          innerY,
          innerX,
          innerY + innerH
        );
        innerGradient.addColorStop(0, "rgba(255,255,255,0.75)");
        innerGradient.addColorStop(1, "rgba(247,229,196,0.92)");

        drawRoundedRect(ctx, innerX, innerY, innerW, innerH, 12 * scale);
        ctx.fillStyle = innerGradient;
        ctx.fill();
        ctx.strokeStyle = "rgba(123, 94, 46, 0.5)";
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        const innerPad = 14 * scale;
        const contentX = innerX + innerPad;
        const contentY = innerY + innerPad;
        const contentW = innerW - innerPad * 2;
        const contentH = innerH - innerPad * 2;
        const gap = 10 * scale;

        let y = contentY;

        const nameFontSize = 16.8 * scale;
        ctx.font = `700 ${nameFontSize}px "Cinzel"`;
        ctx.fillStyle = "#231d14";
        ctx.textBaseline = "top";
        ctx.textAlign = "left";
        ctx.fillText(cardSpec.name, contentX, y);
        const nameHeight = nameFontSize * 1.1;

        const attrText = cardSpec.attribute;
        const attrFontSize = 11.2 * scale;
        ctx.font = `600 ${attrFontSize}px "Rajdhani"`;
        const attrPaddingX = 8 * scale;
        const attrPaddingY = 4 * scale;
        const dotSize = 8 * scale;
        const dotGap = 6 * scale;
        const attrTextWidth = ctx.measureText(attrText).width;
        const pillWidth =
          attrPaddingX * 2 + dotSize + dotGap + attrTextWidth;
        const pillHeight = attrFontSize + attrPaddingY * 2;
        const pillX = contentX + contentW - pillWidth;
        const pillY = y + (nameHeight - pillHeight) * 0.3;
        const pillGradient = ctx.createLinearGradient(
          pillX,
          pillY,
          pillX + pillWidth,
          pillY + pillHeight
        );
        pillGradient.addColorStop(0, "#4b7a3b");
        pillGradient.addColorStop(1, "#274026");

        drawRoundedRect(ctx, pillX, pillY, pillWidth, pillHeight, pillHeight / 2);
        ctx.fillStyle = pillGradient;
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.lineWidth = 1 * scale;
        ctx.stroke();

        const dotX = pillX + attrPaddingX + dotSize / 2;
        const dotY = pillY + pillHeight / 2;
        const dotGradient = ctx.createRadialGradient(
          dotX - dotSize * 0.2,
          dotY - dotSize * 0.2,
          dotSize * 0.2,
          dotX,
          dotY,
          dotSize * 0.6
        );
        dotGradient.addColorStop(0, "#dff5c5");
        dotGradient.addColorStop(1, "#3a6c2c");
        ctx.fillStyle = dotGradient;
        ctx.shadowColor = "rgba(223,245,197,0.8)";
        ctx.shadowBlur = 6 * scale;
        ctx.beginPath();
        ctx.arc(dotX, dotY, dotSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "#f4f2e6";
        ctx.textBaseline = "middle";
        ctx.fillText(attrText, dotX + dotSize / 2 + dotGap, dotY);

        y += nameHeight + gap * 0.6;

        const metaFontSize = 11.5 * scale;
        ctx.font = `600 ${metaFontSize}px "Rajdhani"`;
        ctx.fillStyle = "#534737";
        ctx.textBaseline = "top";
        ctx.textAlign = "left";
        ctx.fillText(cardSpec.typeLine.toUpperCase(), contentX, y);

        const levelFontSize = 12 * scale;
        ctx.font = `600 ${levelFontSize}px "Rajdhani"`;
        const levelText = "LEVEL";
        const levelTextWidth = ctx.measureText(levelText).width;
        const starSize = 14 * scale;
        const starGap = 4 * scale;
        const starsWidth =
          cardSpec.level * starSize + (cardSpec.level - 1) * starGap;
        const levelGroupWidth = levelTextWidth + 8 * scale + starsWidth;
        const levelX = contentX + contentW - levelGroupWidth;
        ctx.textAlign = "left";
        ctx.fillText(levelText, levelX, y);

        const starsX = levelX + levelTextWidth + 8 * scale;
        const starCenterY = y + levelFontSize * 0.7;
        ctx.fillStyle = "#f5d37a";
        ctx.shadowColor = "rgba(245,211,122,0.6)";
        ctx.shadowBlur = 6 * scale;

        for (let i = 0; i < cardSpec.level; i += 1) {
          const cx = starsX + i * (starSize + starGap) + starSize / 2;
          const cy = starCenterY;
          drawStar(ctx, cx, cy, 5, starSize / 2, starSize / 4);
          ctx.fill();
        }
        ctx.shadowBlur = 0;

        const metaHeight = levelFontSize + 4 * scale;
        y += metaHeight + gap;

        const effectTitleFontSize = 11 * scale;
        const effectFontSize = 11.5 * scale;
        const effectLineHeight = effectFontSize * 1.35;
        const effectPaddingX = 9 * scale;
        const effectPaddingY = 8 * scale;
        const effectTitleGap = 6 * scale;
        ctx.font = `600 ${effectFontSize}px "Spectral"`;
        const effectLines = wrapText(
          ctx,
          cardSpec.effectText,
          contentW - effectPaddingX * 2
        );
        const effectBoxHeight =
          effectPaddingY * 2 +
          effectTitleFontSize +
          effectTitleGap +
          effectLines.length * effectLineHeight;

        const flavorFontSize = 11.5 * scale;
        const flavorHeight = flavorFontSize * 1.4;
        const statsFontSize = 12.5 * scale;
        const statsHeight = statsFontSize * 1.3;

        const artHeight =
          contentH -
          (nameHeight +
            metaHeight +
            effectBoxHeight +
            flavorHeight +
            statsHeight +
            gap * 4);

        const artX = contentX;
        const artY = y;
        const artW = contentW;
        const artH = Math.max(artHeight, 160 * scale);

        const artGradient = ctx.createLinearGradient(
          artX,
          artY,
          artX + artW,
          artY + artH
        );
        artGradient.addColorStop(0, "#182e33");
        artGradient.addColorStop(0.6, "#0c1214");
        artGradient.addColorStop(1, "#1a1f14");

        drawRoundedRect(ctx, artX, artY, artW, artH, 8 * scale);
        ctx.fillStyle = artGradient;
        ctx.fill();
        ctx.save();
        ctx.clip();
        drawImageCover(ctx, image, artX, artY, artW, artH);
        ctx.restore();
        ctx.strokeStyle = "rgba(123, 94, 46, 0.7)";
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();

        y = artY + artH + gap;

        const effectX = contentX;
        const effectY = y;
        const effectW = contentW;
        const effectH = effectBoxHeight;
        const effectGradient = ctx.createLinearGradient(
          effectX,
          effectY,
          effectX,
          effectY + effectH
        );
        effectGradient.addColorStop(0, "rgba(255,255,255,0.65)");
        effectGradient.addColorStop(1, "rgba(241,224,196,0.85)");

        drawRoundedRect(ctx, effectX, effectY, effectW, effectH, 6 * scale);
        ctx.fillStyle = effectGradient;
        ctx.fill();
        ctx.strokeStyle = "rgba(123, 94, 46, 0.35)";
        ctx.lineWidth = 1.2 * scale;
        ctx.stroke();

        ctx.fillStyle = "#534737";
        ctx.font = `600 ${effectTitleFontSize}px "Rajdhani"`;
        ctx.textBaseline = "top";
        ctx.textAlign = "left";
        ctx.fillText(
          "EFFECT",
          effectX + effectPaddingX,
          effectY + effectPaddingY
        );

        ctx.fillStyle = "#231d14";
        ctx.font = `400 ${effectFontSize}px "Spectral"`;
        let textY = effectY + effectPaddingY + effectTitleFontSize + effectTitleGap;
        effectLines.forEach((line) => {
          ctx.fillText(line, effectX + effectPaddingX, textY);
          textY += effectLineHeight;
        });

        y = effectY + effectH + gap;

        ctx.fillStyle = "#4f3e2a";
        ctx.font = `italic 400 ${flavorFontSize}px "Spectral"`;
        ctx.textAlign = "right";
        ctx.textBaseline = "top";
        ctx.fillText(cardSpec.flavorText, contentX + contentW, y);

        y += flavorHeight + gap * 0.5;

        ctx.textAlign = "left";
        ctx.font = `600 ${statsFontSize}px "Rajdhani"`;
        ctx.fillStyle = "#534737";
        ctx.fillText("ATK / DEF", contentX, y);

        ctx.textAlign = "right";
        ctx.fillStyle = "#231d14";
        ctx.fillText(`${cardSpec.atk} / ${cardSpec.def}`, contentX + contentW, y);

        return canvas;
      };

      const buildBackTexture = (image) => {
        const width = 1024;
        const height = Math.round((width * 86) / 59);
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        const scale = width / 420;

        const frameGradient = ctx.createLinearGradient(0, 0, width, height);
        frameGradient.addColorStop(0, "#e6c98b");
        frameGradient.addColorStop(0.45, "#7b5e2e");
        frameGradient.addColorStop(1, "#1e1a12");
        drawRoundedRect(ctx, 0, 0, width, height, 16 * scale);
        ctx.fillStyle = frameGradient;
        ctx.fill();

        const outerPad = 12 * scale;
        const innerX = outerPad;
        const innerY = outerPad;
        const innerW = width - outerPad * 2;
        const innerH = height - outerPad * 2;

        drawRoundedRect(ctx, innerX, innerY, innerW, innerH, 12 * scale);
        ctx.save();
        ctx.clip();
        drawImageCover(ctx, image, innerX, innerY, innerW, innerH);
        ctx.restore();
        ctx.strokeStyle = "rgba(123, 94, 46, 0.45)";
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        return canvas;
      };

      const createGlowTexture = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
        gradient.addColorStop(0, "rgba(120,255,220,0.6)");
        gradient.addColorStop(0.5, "rgba(32,160,255,0.25)");
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);
        return canvas;
      };

      const createAuraTexture = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        const center = 256;

        const gradient = ctx.createRadialGradient(
          center,
          center,
          0,
          center,
          center,
          256
        );
        gradient.addColorStop(0, "rgba(120,255,240,0.7)");
        gradient.addColorStop(0.35, "rgba(80,200,255,0.35)");
        gradient.addColorStop(0.7, "rgba(60,140,255,0.16)");
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        ctx.globalCompositeOperation = "screen";
        const rim = ctx.createRadialGradient(center, center, 140, center, center, 256);
        rim.addColorStop(0, "rgba(255,255,255,0)");
        rim.addColorStop(0.7, "rgba(255,255,255,0.22)");
        rim.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = rim;
        ctx.fillRect(0, 0, 512, 512);
        ctx.globalCompositeOperation = "source-over";

        return canvas;
      };

      const createWaveTexture = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        const center = 256;

        const ring = ctx.createRadialGradient(center, center, 120, center, center, 256);
        ring.addColorStop(0, "rgba(0,0,0,0)");
        ring.addColorStop(0.45, "rgba(120,220,255,0.0)");
        ring.addColorStop(0.6, "rgba(120,220,255,0.35)");
        ring.addColorStop(0.78, "rgba(80,180,255,0.2)");
        ring.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = ring;
        ctx.fillRect(0, 0, 512, 512);

        ctx.globalCompositeOperation = "screen";
        const glow = ctx.createRadialGradient(center, center, 0, center, center, 256);
        glow.addColorStop(0, "rgba(255,255,255,0)");
        glow.addColorStop(0.5, "rgba(255,255,255,0.08)");
        glow.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, 512, 512);
        ctx.globalCompositeOperation = "source-over";

        return canvas;
      };

      const createMeteorTexture = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 96;
        const ctx = canvas.getContext("2d");
        const centerY = canvas.height / 2;

        const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, "rgba(0,0,0,0)");
        gradient.addColorStop(0.12, "rgba(120,10,0,0.25)");
        gradient.addColorStop(0.35, "rgba(255,60,0,0.75)");
        gradient.addColorStop(0.62, "rgba(255,140,20,0.9)");
        gradient.addColorStop(0.85, "rgba(255,220,120,0.95)");
        gradient.addColorStop(1, "rgba(255,255,240,1)");

        ctx.fillStyle = gradient;
        ctx.fillRect(0, centerY - 16, canvas.width, 32);

        ctx.globalCompositeOperation = "lighter";
        for (let i = 0; i < 16; i += 1) {
          const x = Math.random() * canvas.width * 0.8;
          const y = centerY + (Math.random() - 0.5) * 26;
          const radius = 8 + Math.random() * 18;
          const flame = ctx.createRadialGradient(x, y, 0, x, y, radius);
          flame.addColorStop(0, "rgba(255,200,80,0.9)");
          flame.addColorStop(0.4, "rgba(255,120,0,0.6)");
          flame.addColorStop(1, "rgba(80,0,0,0)");
          ctx.fillStyle = flame;
          ctx.beginPath();
          ctx.ellipse(x, y, radius * 1.1, radius * 0.6, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.globalCompositeOperation = "screen";
        const core = ctx.createLinearGradient(0, 0, canvas.width, 0);
        core.addColorStop(0, "rgba(255,255,255,0)");
        core.addColorStop(0.5, "rgba(255,255,255,0.75)");
        core.addColorStop(1, "rgba(255,255,255,1)");
        ctx.fillStyle = core;
        ctx.fillRect(0, centerY - 6, canvas.width, 12);
        ctx.globalCompositeOperation = "source-over";

        return canvas;
      };

      const pulseGlow = (time, intensity = 1) => {
        return 0.8 + Math.sin(time * 1.6) * 0.2 * intensity;
      };

      const createStarLayer = (count, spread, size, speed, color) => {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const nearZ = -2;
        const farZ = -spread - 6;
        for (let i = 0; i < count; i += 1) {
          positions[i * 3] = (Math.random() - 0.5) * spread;
          positions[i * 3 + 1] = (Math.random() - 0.5) * spread;
          positions[i * 3 + 2] = farZ + Math.random() * (nearZ - farZ);
        }
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        const material = new THREE.PointsMaterial({
          color,
          size,
          transparent: true,
          opacity: 0.7,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });
        const points = new THREE.Points(geometry, material);
        return { points, positions, spread, speed, material, nearZ, farZ };
      };

      const init = async () => {
        if (document.fonts && document.fonts.ready) {
          await document.fonts.ready;
        }
        const artImage = await loadImage("assets/image.png");
        const backImage = await loadImage("assets/wc.png");
        const frontCanvas = buildFrontTexture(artImage);
        const backCanvas = buildBackTexture(backImage);
        const frontTexture = new THREE.CanvasTexture(frontCanvas);
        const backTexture = new THREE.CanvasTexture(backCanvas);
        frontTexture.colorSpace = THREE.SRGBColorSpace;
        backTexture.colorSpace = THREE.SRGBColorSpace;
        frontTexture.needsUpdate = true;
        backTexture.needsUpdate = true;
        frontTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        backTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        const cardWidth = 2.4;
        const cardHeight = (cardWidth * 86) / 59;
        const cardDepth = 0.06;
        const cornerRadius = 0.14;

        const sideMaterial = new THREE.MeshStandardMaterial({
          color: "#241c12",
          roughness: 0.7,
          metalness: 0.1
        });
        const frontMaterial = new THREE.MeshStandardMaterial({
          map: frontTexture,
          roughness: 0.55,
          metalness: 0.2
        });
        const backMaterial = new THREE.MeshStandardMaterial({
          map: backTexture,
          roughness: 0.6,
          metalness: 0.15
        });

        const cardMaterials = [
          sideMaterial,
          sideMaterial,
          sideMaterial,
          sideMaterial,
          frontMaterial,
          backMaterial
        ];

        const cardGeometry = new RoundedBoxGeometry(
          cardWidth,
          cardHeight,
          cardDepth,
          6,
          cornerRadius
        );
        const cardMesh = new THREE.Mesh(cardGeometry, cardMaterials);
        scene.add(cardMesh);

        const holoUniforms = {
          uTime: { value: 0 },
          uIntensity: { value: 0.35 }
        };

        const holoMaterial = new THREE.ShaderMaterial({
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          uniforms: holoUniforms,
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform float uIntensity;
            varying vec2 vUv;

            float hash(vec2 p) {
              return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
            }

            void main() {
              float wave = sin((vUv.x + uTime * 0.08) * 18.0) * 0.5 + 0.5;
              float wave2 = sin((vUv.y + uTime * 0.12) * 14.0) * 0.5 + 0.5;
              float noise = hash(vUv * 12.0 + uTime * 0.2);
              float diag = abs(sin((vUv.x + vUv.y + uTime * 0.04) * 60.0));
              float stripe = smoothstep(0.72, 0.95, diag);
              float grid = abs(sin(vUv.x * 110.0) * sin(vUv.y * 110.0));
              grid = smoothstep(0.86, 0.99, grid);
              float speck = step(0.975, noise);
              float pattern = stripe * 0.6 + grid * 0.35 + speck * 0.25;
              vec3 colorA = vec3(0.2, 0.9, 1.0);
              vec3 colorB = vec3(1.0, 0.6, 0.2);
              vec3 color = mix(colorA, colorB, wave);
              vec3 prism = mix(vec3(0.2, 0.85, 1.0), vec3(1.0, 0.5, 0.8), vUv.y);
              color = mix(color, prism, pattern * 0.25);
              color += noise * 0.08;
              float alpha =
                (0.12 + wave * 0.32 + wave2 * 0.18 + pattern * 0.16) * uIntensity;
              gl_FragColor = vec4(color, alpha);
            }
          `
        });

        const holoShape = createRoundedRectShape(
          cardWidth * 0.98,
          cardHeight * 0.98,
          cornerRadius * 0.9
        );
        const holoPlane = new THREE.Mesh(
          new THREE.ShapeGeometry(holoShape),
          holoMaterial
        );
        holoPlane.position.z = cardDepth / 2 + 0.002;
        cardMesh.add(holoPlane);

        const glowTexture = new THREE.CanvasTexture(createGlowTexture());
        glowTexture.colorSpace = THREE.SRGBColorSpace;
        const glowMaterial = new THREE.SpriteMaterial({
          map: glowTexture,
          transparent: true,
          opacity: 0.2,
          depthWrite: false,
          depthTest: false,
          blending: THREE.AdditiveBlending
        });
        const glowSprite = new THREE.Sprite(glowMaterial);
        glowSprite.scale.set(cardWidth * 1.5, cardHeight * 1.5, 1);
        glowSprite.position.z = -cardDepth * 4;
        glowSprite.renderOrder = 2;
        cardMesh.add(glowSprite);

        const auraTexture = new THREE.CanvasTexture(createAuraTexture());
        auraTexture.colorSpace = THREE.SRGBColorSpace;
        const auraMaterial = new THREE.SpriteMaterial({
          map: auraTexture,
          transparent: true,
          opacity: 0.85,
          depthWrite: false,
          depthTest: true,
          blending: THREE.AdditiveBlending
        });
        const auraSprite = new THREE.Sprite(auraMaterial);
        const auraBaseScale = {
          x: cardWidth * 3.1,
          y: cardHeight * 3.1
        };
        auraSprite.scale.set(auraBaseScale.x, auraBaseScale.y, 1);
        auraSprite.renderOrder = 1;
        scene.add(auraSprite);

        const waveTexture = new THREE.CanvasTexture(createWaveTexture());
        waveTexture.colorSpace = THREE.SRGBColorSpace;
        const waveBaseScale = {
          x: cardWidth * 3.4,
          y: cardHeight * 3.4
        };
        const waveSprites = [0, 1].map((index) => {
          const waveMaterial = new THREE.SpriteMaterial({
            map: waveTexture,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            depthTest: true,
            blending: THREE.AdditiveBlending
          });
          const sprite = new THREE.Sprite(waveMaterial);
          sprite.scale.set(waveBaseScale.x, waveBaseScale.y, 1);
          sprite.renderOrder = 0;
          sprite.userData.phaseOffset = index * 0.5;
          scene.add(sprite);
          return sprite;
        });

        const shockwaveMaterial = new THREE.MeshBasicMaterial({
          color: "#ffffff",
          transparent: true,
          opacity: 0,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        const shockwave = new THREE.Mesh(
          new THREE.RingGeometry(0.2, 0.26, 64),
          shockwaveMaterial
        );
        shockwave.visible = false;
        shockwave.position.z = cardDepth / 2 + 0.01;
        cardMesh.add(shockwave);

        const starLayers = [
          createStarLayer(900, 28, 0.05, 0.35, 0xffffff),
          createStarLayer(700, 22, 0.08, 0.55, 0xffe6cc),
          createStarLayer(450, 18, 0.12, 0.8, 0xcff6ff)
        ];

        starLayers.forEach((layer) => {
          scene.add(layer.points);
        });

        const meteorTexture = new THREE.CanvasTexture(createMeteorTexture());
        meteorTexture.colorSpace = THREE.SRGBColorSpace;
        const meteorGroup = new THREE.Group();
        meteorGroup.visible = false;
        const meteorCount = 60;
        const meteorField = [];
        const meteorBounds = {
          x: 10,
          y: 6,
          nearZ: -1.5,
          farZ: -26
        };
        const meteorBaseDirection = new THREE.Vector3(0.7, -0.3, 1).normalize();

        const resetMeteor = (meteor) => {
          const offset = (Math.random() - 0.5) * 0.6;
          meteor.userData.direction
            .copy(meteorBaseDirection)
            .applyAxisAngle(new THREE.Vector3(0, 0, 1), offset);
          meteor.position.set(
            (Math.random() - 0.5) * meteorBounds.x * 2,
            (Math.random() - 0.5) * meteorBounds.y * 2,
            meteorBounds.farZ - Math.random() * 12
          );
          meteor.userData.speed = 4.5 + Math.random() * 4.2;
          meteor.userData.opacity = 0.4 + Math.random() * 0.4;
        };

        for (let i = 0; i < meteorCount; i += 1) {
          const meteorMaterial = new THREE.SpriteMaterial({
            map: meteorTexture,
            color: 0xffb069,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            depthTest: true,
            blending: THREE.AdditiveBlending
          });
          const meteor = new THREE.Sprite(meteorMaterial);
          const scaleX = 3.6 + Math.random() * 3.6;
          const scaleY = 0.35 + Math.random() * 0.2;
          meteor.userData.baseScale = new THREE.Vector2(scaleX, scaleY);
          meteor.scale.set(scaleX, scaleY, 1);
          meteor.material.rotation = -0.6 + Math.random() * 0.3;
          meteor.userData.direction = new THREE.Vector3();
          resetMeteor(meteor);
          meteorField.push(meteor);
          meteorGroup.add(meteor);
        }

        scene.add(meteorGroup);

        const world = new CANNON.World({
          gravity: new CANNON.Vec3(0, 0, 0)
        });
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 10;

        const cardShape = new CANNON.Box(
          new CANNON.Vec3(cardWidth / 2, cardHeight / 2, cardDepth / 2)
        );
        const cardBody = new CANNON.Body({
          mass: 1,
          shape: cardShape,
          linearDamping: 0.9,
          angularDamping: 0.85
        });
        world.addBody(cardBody);

        const anchorBody = new CANNON.Body({ mass: 0 });
        world.addBody(anchorBody);
        const spring = new CANNON.Spring(anchorBody, cardBody, {
          restLength: 0,
          stiffness: 90,
          damping: 10
        });

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let hoverActive = false;
        let isDragging = false;
        let dragMoved = false;
        let suppressClick = false;
        let startX = 0;
        let startY = 0;
        let spinX = 0;
        let spinY = 0;
        let hoverX = 0;
        let hoverY = 0;
        let targetLift = 0;
        let glowTarget = 0.2;
        let auraTarget = 0.95;
        let holoTarget = 0.35;
        let warpStrength = 0;
        let warpTarget = 0;
        let warpTimer = 0;
        const baseCameraZ = camera.position.z;
        const zoomDuration = 2.6;
        const zoomDistance = 1.7;
        let zoomTimer = 0;
        let eventBoost = 0;
        let meteorTimer = 0;
        let shockwaveStart = 0;
        let shockwaveActive = false;
        let shakeTimer = 0;

        const edgeThreshold = 0.18;
        const dragThreshold = 4;
        const spinFactor = 0.005;
        const maxSpinX = 0.45;
        const maxTilt = THREE.MathUtils.degToRad(12);
        const hoverLift = 0.35;

        const normalizeAngle = (angle) => {
          const twoPi = Math.PI * 2;
          return ((angle + Math.PI) % twoPi + twoPi) % twoPi - Math.PI;
        };

        const snapAngle = (angle) => {
          const normalized = normalizeAngle(angle);
          return Math.abs(normalized) < Math.PI / 2
            ? 0
            : normalized > 0
            ? Math.PI
            : -Math.PI;
        };

        const approachAngle = (current, target, factor) => {
          const delta = normalizeAngle(target - current);
          return current + delta * factor;
        };

        const isBackFace = () => Math.abs(normalizeAngle(spinY)) > Math.PI / 2;

        const updatePointer = (event) => {
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        };

        const getIntersection = () => {
          raycaster.setFromCamera(pointer, camera);
          return raycaster.intersectObject(cardMesh, false)[0] || null;
        };

        const resetHover = () => {
          hoverActive = false;
          hoverX = 0;
          hoverY = 0;
          targetLift = 0;
          glowTarget = 0.2;
          auraTarget = 0.95;
          holoTarget = 0.35;
        };

        const handlePointerMove = (event) => {
          if (!motionEnabled) {
            return;
          }

          if (isDragging) {
            const deltaX = event.clientX - startX;
            const deltaY = event.clientY - startY;

            if (
              !dragMoved &&
              (Math.abs(deltaX) > dragThreshold ||
                Math.abs(deltaY) > dragThreshold)
            ) {
              dragMoved = true;
            }

            spinY += deltaX * spinFactor;
            spinX = Math.max(
              Math.min(spinX - deltaY * spinFactor * 0.6, maxSpinX),
              -maxSpinX
            );

            if (spinY > Math.PI) {
              spinY -= Math.PI * 2;
            } else if (spinY < -Math.PI) {
              spinY += Math.PI * 2;
            }

            startX = event.clientX;
            startY = event.clientY;
            return;
          }

          updatePointer(event);
          const hit = getIntersection();
          if (!hit || !hit.uv) {
            resetHover();
            return;
          }

          const isFront = hit.face && hit.face.materialIndex === 4;
          if (!isFront) {
            resetHover();
            return;
          }

          const xPercent = hit.uv.x;
          const yPercent = 1 - hit.uv.y;
          hoverX = (0.5 - yPercent) * maxTilt;
          hoverY = (xPercent - 0.5) * maxTilt;
          targetLift = hoverLift;
          glowTarget = 0.3;
          auraTarget = 1.1;
          holoTarget = 0.6;
          hoverActive = true;
        };

        const handlePointerDown = (event) => {
          if (!motionEnabled) {
            return;
          }

          updatePointer(event);
          const hit = getIntersection();
          if (!hit || !hit.uv) {
            return;
          }

          const onEdge =
            hit.uv.x < edgeThreshold ||
            hit.uv.x > 1 - edgeThreshold ||
            hit.uv.y < edgeThreshold ||
            hit.uv.y > 1 - edgeThreshold;
          if (!onEdge) {
            return;
          }

          isDragging = true;
          dragMoved = false;
          suppressClick = false;
          startX = event.clientX;
          startY = event.clientY;
          targetLift = hoverLift;
          renderer.domElement.classList.add("is-dragging");
          renderer.domElement.setPointerCapture(event.pointerId);
        };

        const handlePointerUp = (event) => {
          if (!isDragging) {
            return;
          }

          isDragging = false;
          suppressClick = dragMoved;
          dragMoved = false;
          spinY = normalizeAngle(spinY);
          spinX = Math.max(Math.min(spinX, maxSpinX), -maxSpinX);
          renderer.domElement.classList.remove("is-dragging");
          if (renderer.domElement.hasPointerCapture(event.pointerId)) {
            renderer.domElement.releasePointerCapture(event.pointerId);
          }
        };

        const triggerImpact = () => {
          if (!motionEnabled) {
            return;
          }
          if (suppressClick) {
            suppressClick = false;
            return;
          }

          warpTarget = 1;
          warpTimer = 0.9;
          zoomTimer = zoomDuration;
          meteorTimer = zoomDuration;
          shockwaveActive = true;
          shockwaveStart = performance.now();
          shakeTimer = 0.4;
        };

        renderer.domElement.addEventListener("pointermove", handlePointerMove);
        renderer.domElement.addEventListener("pointerdown", handlePointerDown);
        renderer.domElement.addEventListener("pointerup", handlePointerUp);
        renderer.domElement.addEventListener("pointercancel", handlePointerUp);
        renderer.domElement.addEventListener("pointerleave", () => {
          if (!isDragging) {
            resetHover();
          }
        });
        renderer.domElement.addEventListener("click", triggerImpact);

        const updatePhysics = (delta) => {
          if (!isDragging) {
            const snappedY = snapAngle(spinY);
            spinY = approachAngle(spinY, snappedY, 0.18);
            if (Math.abs(normalizeAngle(spinY - snappedY)) < 0.02) {
              spinY = snappedY;
            }

            spinX += (0 - spinX) * 0.12;
            if (Math.abs(spinX) < 0.02) {
              spinX = 0;
            }
          }

          anchorBody.position.set(0, 0, targetLift);
          spring.applyForce();

          const targetRotX = spinX + hoverX;
          const targetRotY = spinY + hoverY;

          const targetQuat = new THREE.Quaternion().setFromEuler(
            new THREE.Euler(targetRotX, targetRotY, 0, "XYZ")
          );
          const currentQuat = new THREE.Quaternion(
            cardBody.quaternion.x,
            cardBody.quaternion.y,
            cardBody.quaternion.z,
            cardBody.quaternion.w
          );
          const quatError = targetQuat.clone().multiply(currentQuat.invert());
          let angle = 2 * Math.acos(Math.max(-1, Math.min(1, quatError.w)));
          if (angle > Math.PI) {
            angle -= Math.PI * 2;
          }
          const axis = new THREE.Vector3(
            quatError.x,
            quatError.y,
            quatError.z
          );
          if (axis.lengthSq() > 0.00001) {
            axis.normalize();
          }

          const torqueStrength = 18;
          const torqueDamping = 6;
          const torque = axis.multiplyScalar(angle * torqueStrength);
          cardBody.torque.set(
            torque.x - cardBody.angularVelocity.x * torqueDamping,
            torque.y - cardBody.angularVelocity.y * torqueDamping,
            torque.z - cardBody.angularVelocity.z * torqueDamping
          );

          if (shakeTimer > 0) {
            shakeTimer -= delta;
            const intensity = Math.max(shakeTimer / 0.4, 0);
            const impulse = new CANNON.Vec3(
              (Math.random() - 0.5) * 1.8 * intensity,
              (Math.random() - 0.5) * 1.8 * intensity,
              (Math.random() - 0.5) * 2.6 * intensity
            );
            cardBody.applyImpulse(impulse, cardBody.position);
            cardBody.angularVelocity.x += (Math.random() - 0.5) * 1.5 * intensity;
            cardBody.angularVelocity.y += (Math.random() - 0.5) * 1.5 * intensity;
          }

          world.step(1 / 60, delta, 3);

          cardMesh.position.set(
            cardBody.position.x,
            cardBody.position.y,
            cardBody.position.z
          );
          cardMesh.quaternion.set(
            cardBody.quaternion.x,
            cardBody.quaternion.y,
            cardBody.quaternion.z,
            cardBody.quaternion.w
          );
        };

        const updateStars = (delta, boost) => {
          const speedBoost = 1 + warpStrength * 4 + boost * 3;
          starLayers.forEach((layer) => {
            const positions = layer.positions;
            for (let i = 0; i < positions.length; i += 3) {
              positions[i + 2] += layer.speed * speedBoost * delta;
              if (positions[i + 2] > layer.nearZ) {
                positions[i + 2] = layer.farZ;
                positions[i] = (Math.random() - 0.5) * layer.spread;
                positions[i + 1] = (Math.random() - 0.5) * layer.spread;
              }
            }
            layer.points.geometry.attributes.position.needsUpdate = true;
            layer.material.opacity = 0.6 + warpStrength * 0.25 + boost * 0.2;
          });
        };

        const updateMeteors = (delta, boost) => {
          const active = meteorTimer > 0 || boost > 0.01;
          meteorGroup.visible = active;
          if (!active) {
            return;
          }

          const speedBoost = 1 + boost * 7.5;
          const scaleBoost = 1 + boost * 0.65;
          const widthBoost = 1 + boost * 0.9;
          meteorField.forEach((meteor) => {
            meteor.material.opacity =
              (0.35 + boost * 0.5) * meteor.userData.opacity;
            const baseScale = meteor.userData.baseScale;
            meteor.scale.set(
              baseScale.x * widthBoost,
              baseScale.y * scaleBoost,
              1
            );
            meteor.position.addScaledVector(
              meteor.userData.direction,
              meteor.userData.speed * speedBoost * delta
            );

            if (meteor.position.z > meteorBounds.nearZ) {
              resetMeteor(meteor);
            }
          });
        };

        const updateHoloAndGlow = (delta, time, eventBoost) => {
          const pulse = pulseGlow(time, hoverActive ? 1.3 : 1);
          const targetGlow = glowTarget * pulse;
          glowMaterial.opacity += (targetGlow - glowMaterial.opacity) * 0.08;

          const targetHolo = holoTarget + pulse * 0.08 + eventBoost * 0.12;
          holoUniforms.uIntensity.value +=
            (targetHolo - holoUniforms.uIntensity.value) * 0.08;
          holoUniforms.uTime.value += delta * 3;

          const auraPulse = pulseGlow(time, hoverActive ? 1.2 : 1);
          const auraBackBoost = isBackFace() ? 1.45 : 1;
          const targetAura = Math.min(
            1.2,
            auraTarget * auraPulse * auraBackBoost + eventBoost * 0.35
          );
          auraMaterial.opacity += (targetAura - auraMaterial.opacity) * 0.08;
          const auraScale = 1 + Math.sin(time * 1.2) * 0.03;
          auraSprite.scale.set(
            auraBaseScale.x * auraScale,
            auraBaseScale.y * auraScale,
            1
          );

          const waveSpeed = 0.35;
          const waveSpread = 0.6;
          const waveBackBoost = isBackFace() ? 1.3 : 1;
          const waveBase = 0.35 + eventBoost * 0.4;
          waveSprites.forEach((sprite) => {
            const phase = (time * waveSpeed + sprite.userData.phaseOffset) % 1;
            const fade = Math.sin(phase * Math.PI);
            const scale = 1 + phase * waveSpread;
            sprite.material.opacity = waveBase * fade * waveBackBoost;
            sprite.scale.set(
              waveBaseScale.x * scale,
              waveBaseScale.y * scale,
              1
            );
          });
        };

        const updateShockwave = (time) => {
          if (!shockwaveActive) {
            return;
          }
          const elapsed = (time - shockwaveStart) / 700;
          if (elapsed >= 1) {
            shockwave.visible = false;
            shockwaveActive = false;
            return;
          }
          shockwave.visible = true;
          const scale = 0.2 + elapsed * 4.8;
          shockwave.scale.set(scale, scale, 1);
          shockwave.material.opacity = (1 - elapsed) * 0.7;
        };

        const clock = new THREE.Clock();
        const animate = () => {
          const delta = clock.getDelta();
          if (motionEnabled) {
            if (zoomTimer > 0) {
              zoomTimer = Math.max(0, zoomTimer - delta);
              const progress = 1 - zoomTimer / zoomDuration;
              eventBoost = Math.sin(progress * Math.PI);
            } else {
              eventBoost = 0;
            }

            if (meteorTimer > 0) {
              meteorTimer = Math.max(0, meteorTimer - delta);
            }

            camera.position.z = baseCameraZ - zoomDistance * eventBoost;
            updatePhysics(delta);
            updateStars(delta, eventBoost);
            updateMeteors(delta, eventBoost);
            updateHoloAndGlow(delta, clock.elapsedTime, eventBoost);

            if (warpTimer > 0) {
              warpTimer = Math.max(0, warpTimer - delta);
              warpTarget = 1;
            } else {
              warpTarget = 0;
            }
            const desiredWarp = Math.min(1, warpTarget + eventBoost * 0.6);
            warpStrength += (desiredWarp - warpStrength) * 0.08;
            updateShockwave(performance.now());
          }

          auraSprite.position.copy(cardMesh.position);
          auraSprite.position.z -= 0.25;
          waveSprites.forEach((sprite) => {
            sprite.position.copy(cardMesh.position);
            sprite.position.z -= 0.4;
          });

          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        };

        animate();
      };

      init();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
